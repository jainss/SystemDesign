ğŸ”§ What is the Decorator Design Pattern? -> SOLVE Class Explosion Problem.
Definition:
The Decorator Pattern allows you to dynamically add behavior to an object without modifying its code. 
Itâ€™s a structural pattern that uses composition instead of inheritance.


âœ¨ Benefits of Decorator Pattern
Benefit	Explanation
âœ… Open/Closed Principle	You can add new functionality (like toppings or sizes) without modifying existing classes.
âœ… Flexible Composition	You can combine decorators in different ways at runtime: e.g. Large Margherita + Cheese + Jalapenos.
âœ… Avoids Class Explosion	Instead of making a class for every possible combination (e.g., CheeseLargeOlivePizza), you dynamically wrap them.
âœ… Single Responsibility	Each decorator adds just one responsibility (e.g., size, cheese, etc.)â€”clear and modular.
âœ… Reusability	You can reuse decorators across different objectsâ€”e.g., same Cheese for both Margherita and FarmHouse.
âœ… Runtime Behavior Change	You can build pizza with any combination at runtime.



ğŸ˜ª Drawbacks of Decorator Pattern
Drawback	Explanation
âŒ Too Many Small Classes	For every feature (e.g., cheese, olives), you create a new class. This may overwhelm the codebase.
âŒ Harder Debugging	Since behavior is wrapped across multiple layers, debugging a decorator chain can be tricky.
âŒ Order Matters	Applying decorators in different order may lead to different results (e.g., pricing or description).
âŒ Complicated Memory Management	In C++, using raw pointers in decorators requires careful new/delete usage (or better, smart pointers).
âŒ No Global View	The final object behavior is split across multiple classes â€” not all behavior is visible in one place.


ğŸ” When to Use It:

âœ… Use Decorator When:
You want to add features dynamically without subclassing
You want to avoid hundreds of subclasses for every feature combo
You want to follow clean OOP principles (open/closed, SRP)

âŒ Avoid Decorator If:
You only have a few fixed combinations\
Simpler inheritance or configuration would do the job
Performance or memory overhead of many layers is a concern


ğŸ• In Your Pizza App
âœ… Good Fit	                                       âŒ Might Be a Problem
Flexible toppings and size combinations	            Many tiny classes (one for each topping/size)
Easily extendable with new toppings	                May become verbose as features grow
Dynamic combinations at runtime	                    Requires good memory management in C++